// Generated by CoffeeScript 1.8.0
(function() {
  var AES_IV_SIZE, BigInt, CHECKSUM_SIZE, MAGIC_BYTES, PUBKEY_SIZE, Point, VERSION, buff_eq, create_ecdh, crypto, getCurveByName, get_pub, hmac, k, rand, rand_key, reader, sha512, v, _ref, _ref1, _ref2;

  crypto = require('crypto');

  BigInt = require('bigi');

  _ref = require('ecurve'), Point = _ref.Point, getCurveByName = _ref.getCurveByName;

  _ref1 = require('./util'), reader = _ref1.reader, sha512 = _ref1.sha512, hmac = _ref1.hmac, rand = _ref1.rand, rand_key = _ref1.rand_key, get_pub = _ref1.get_pub, buff_eq = _ref1.buff_eq;

  VERSION = 1;

  MAGIC_BYTES = new Buffer([0x09, 0x43, 0x3d, 0x07, VERSION]);

  PUBKEY_SIZE = 33;

  CHECKSUM_SIZE = 32;

  AES_IV_SIZE = 16;

  create_ecdh = function(curve_name, cipher_algo) {
    var curve, shared_secret;
    curve = getCurveByName(curve_name);
    shared_secret = function(d, Q) {
      if (Buffer.isBuffer(d)) {
        d = BigInt.fromBuffer(d);
      }
      if (Buffer.isBuffer(Q)) {
        Q = Point.decodeFrom(curve, Q);
      }
      return sha512(Q.multiply(d).affineX.toBuffer());
    };
    return {
      encrypt: function(pubkey, msg) {
        var checksum, cipher, ct, eph, iv, secret;
        eph = rand_key(curve, pubkey, msg);
        secret = shared_secret(eph, pubkey);
        iv = rand(secret, msg).slice(0, AES_IV_SIZE);
        cipher = crypto.createCipheriv(cipher_algo, secret.slice(0, 32), iv);
        cipher.setAutoPadding(true);
        ct = cipher.update(msg);
        ct = Buffer.concat([ct, cipher.final()]);
        checksum = hmac(secret.slice(32, 64), iv, ct);
        return Buffer.concat([MAGIC_BYTES, get_pub(curve, eph), checksum, iv, ct]);
      },
      decrypt: function(privkey, enc) {
        var checksum, cipher, ct, iv, msg, read, secret;
        read = reader(enc);
        if (!buff_eq(MAGIC_BYTES, read(MAGIC_BYTES.length))) {
          throw new Error('Invalid magic bytes');
        }
        secret = shared_secret(privkey, read(PUBKEY_SIZE));
        checksum = read(CHECKSUM_SIZE);
        iv = read(AES_IV_SIZE);
        ct = read();
        if (!buff_eq(checksum, hmac(secret.slice(32, 64), iv, ct))) {
          throw new Error('Invalid checksum');
        }
        cipher = crypto.createDecipheriv(cipher_algo, secret.slice(0, 32), iv);
        cipher.setAutoPadding(true);
        msg = cipher.update(ct);
        return Buffer.concat([msg, cipher.final()]);
      }
    };
  };

  module.exports = create_ecdh;

  _ref2 = create_ecdh('secp256k1', 'AES-256-CBC');
  for (k in _ref2) {
    v = _ref2[k];
    module.exports[k] = v;
  }

}).call(this);
